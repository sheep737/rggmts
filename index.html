<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ver:8</title>
<style>
body {
  margin: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

canvas {
  background: black;
  image-rendering: pixelated;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const tileSize = 24;
const mapW = 15;
const mapH = 10;
const canvas = document.getElementById("game");
canvas.width = mapW * tileSize;
canvas.height = mapH * tileSize;
const ctx = canvas.getContext("2d");

let map = [];
for (let y = 0; y < mapH; y++) {
  let row = [];
  for (let x = 0; x < mapW; x++) {
    row.push(
      x === 0 || y === 0 || x === mapW - 1 || y === mapH - 1 ? 1 : 0
    );
  }
  map.push(row);
}

let enemies = [
  { x: mapW - 3, y: mapH - 3, dir: { x: -1, y: 0 }, alive: true }
];

const start = getRandomEmptyCell();

let player = {
  x: start.x,
  y: start.y,
  dir: { x: 1, y: 0 },
  cooldown: 0
};

let bullets = [];

function moveBullets() {
  bullets.forEach(b => {
    if (!b.alive) return;

    b.x += b.dir.x;
    b.y += b.dir.y;

if (
  b.x < 0 || b.x >= mapW ||
  b.y < 0 || b.y >= mapH ||
  map[b.y][b.x] === 1
) {
  b.alive = false;
}

    enemies.forEach(e => {
      if (e.alive && e.x === b.x && e.y === b.y) {
        e.alive = false;
        b.alive = false;
      }
    });
  });

  bullets = bullets.filter(b => b.alive);
}

function getRandomEmptyCell() {
  while (true) {
    const x = Math.floor(Math.random() * mapW);
    const y = Math.floor(Math.random() * mapH);

    // 床マスのみ
    if (map[y][x] !== 0) continue;

    // 敵と被らない
    const hitEnemy = enemies.some(e => e.x === x && e.y === y);
    if (hitEnemy) continue;

    return { x, y };
  }
}

function tryShoot(player, enemy) {
  if (player.cooldown > 0) return;

  const dx = enemy.x - player.x;
  const dy = enemy.y - player.y;

  // 上下左右にいる時だけ撃つ
  if (dx === 0 || dy === 0) {
    player.dir = {
      x: Math.sign(dx),
      y: Math.sign(dy)
    };

    bullets.push({
      x: player.x + player.dir.x,
      y: player.y + player.dir.y,
      dir: { ...player.dir },
      alive: true
    });

    player.cooldown = 5; // 発射間隔
  }
}

function chaseEnemy(enemy, player) {
  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;

  // 距離が大きい方向を優先
  if (Math.abs(dx) > Math.abs(dy)) {
    enemy.dir = { x: Math.sign(dx), y: 0 };
  } else {
    enemy.dir = { x: 0, y: Math.sign(dy) };
  }
}

function draw() {

  for (let y = 0; y < mapH; y++) {
    for (let x = 0; x < mapW; x++) {
      ctx.fillStyle = map[y][x] === 1 ? "#664422" : "#111";
      ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    }
  }

  ctx.fillStyle = "#3af";
  ctx.fillRect(
    player.x * tileSize + 4,
    player.y * tileSize + 4,
    tileSize - 8,
    tileSize - 8
  );

// 攻撃アニメーション
if (player.attackTimer > 0) {
  ctx.fillStyle = "#fff";

  const ax = player.x + player.dir.x;
  const ay = player.y + player.dir.y;

  ctx.fillRect(
    ax * tileSize + 8,
    ay * tileSize + 8,
    tileSize - 16,
    tileSize - 16
  );
}

enemies.forEach(enemy => {
  if (enemy.alive) {
    ctx.fillStyle = "#f33";
    ctx.fillRect(
      enemy.x * tileSize + 4,
      enemy.y * tileSize + 4,
      tileSize - 8,
      tileSize - 8
    );
  }
});

// 弾
ctx.fillStyle = "#ff0";
bullets.forEach(b => {
  ctx.fillRect(
    b.x * tileSize + 10,
    b.y * tileSize + 10,
    tileSize - 20,
    tileSize - 20
  );
});

}

function autoMove(chara) {
  let nx = chara.x + chara.dir.x;
  let ny = chara.y + chara.dir.y;

  if (
    nx < 0 || nx >= mapW ||
    ny < 0 || ny >= mapH ||
    map[ny][nx] === 1
  ) {
    const dirs = [
      { x: 1, y: 0 },
      { x: -1, y: 0 },
      { x: 0, y: 1 },
      { x: 0, y: -1 }
    ];
    chara.dir = dirs[Math.floor(Math.random() * dirs.length)];
    return;
  }

  chara.x = nx;
  chara.y = ny;
}

let timer = null;

function loop() {

  autoMove(player);

  if (player.cooldown > 0) player.cooldown--;

  enemies.forEach(enemy => {
    if (!enemy.alive) return;

    chaseEnemy(enemy, player);
    autoMove(enemy);

    tryShoot(player, enemy);

    if (player.x === enemy.x && player.y === enemy.y) {
      draw();
      clearInterval(timer);
      alert("ゲームオーバー");
    }
  });

  moveBullets();

  const allDead = enemies.every(e => !e.alive);
  if (allDead) {
    draw();
    clearInterval(timer);
    alert("敵を全滅させた！");
    return;
  }

  draw();
}

draw();
timer = setInterval(loop, 300);

</script>
</body>
</html>
