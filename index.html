<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ver:5</title>
<style>
body {
  margin: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}

canvas {
  background: black;
  image-rendering: pixelated;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const tileSize = 24;
const mapW = 15;
const mapH = 10;
const canvas = document.getElementById("game");
canvas.width = mapW * tileSize;
canvas.height = mapH * tileSize;
const ctx = canvas.getContext("2d");

let map = [];
for (let y = 0; y < mapH; y++) {
  let row = [];
  for (let x = 0; x < mapW; x++) {
    row.push(
      x === 0 || y === 0 || x === mapW - 1 || y === mapH - 1 ? 1 : 0
    );
  }
  map.push(row);
}

let player = {
  x: 2,
  y: 2,
  dir: { x: 1, y: 0 }
};

let enemies = [
  { x: mapW - 3, y: mapH - 3, dir: { x: -1, y: 0 }, alive: true }
];

function playerAttack(player, enemy) {
  const dx = Math.abs(player.x - enemy.x);
  const dy = Math.abs(player.y - enemy.y);

  // 上下左右に隣接していたら攻撃成功
  if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
    return true;
  }
  return false;
}

function chaseEnemy(enemy, player) {
  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;

  // 距離が大きい方向を優先
  if (Math.abs(dx) > Math.abs(dy)) {
    enemy.dir = { x: Math.sign(dx), y: 0 };
  } else {
    enemy.dir = { x: 0, y: Math.sign(dy) };
  }
}

function draw() {
  for (let y = 0; y < mapH; y++) {
    for (let x = 0; x < mapW; x++) {
      ctx.fillStyle = map[y][x] === 1 ? "#664422" : "#111";
      ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    }
  }

  ctx.fillStyle = "#3af";
  ctx.fillRect(
    player.x * tileSize + 4,
    player.y * tileSize + 4,
    tileSize - 8,
    tileSize - 8
  );

enemies.forEach(enemy => {
  if (enemy.alive) {
    ctx.fillStyle = "#f33";
    ctx.fillRect(
      enemy.x * tileSize + 4,
      enemy.y * tileSize + 4,
      tileSize - 8,
      tileSize - 8
    );
  }
});

}

function autoMove(chara) {
  let nx = chara.x + chara.dir.x;
  let ny = chara.y + chara.dir.y;

  if (
    nx < 0 || nx >= mapW ||
    ny < 0 || ny >= mapH ||
    map[ny][nx] === 1
  ) {
    const dirs = [
      { x: 1, y: 0 },
      { x: -1, y: 0 },
      { x: 0, y: 1 },
      { x: 0, y: -1 }
    ];
    chara.dir = dirs[Math.floor(Math.random() * dirs.length)];
    return;
  }

  chara.x = nx;
  chara.y = ny;
}

let timer = null;

function loop() {
  autoMove(player);

  enemies.forEach(enemy => {
    if (!enemy.alive) return;

    chaseEnemy(enemy, player);
    autoMove(enemy);

    if (playerAttack(player, enemy)) {
      enemy.alive = false;
    }

    if (player.x === enemy.x && player.y === enemy.y) {
      draw();
      clearInterval(timer);
      alert("ゲームオーバー");
    }
  });

  const allDead = enemies.every(e => !e.alive);
  if (allDead) {
    draw();
    clearInterval(timer);
    alert("敵を全滅させた！");
    return;
  }

  draw();
}

draw();
timer = setInterval(loop, 300);

</script>
</body>
</html>
